---
title:  "Video Game Development"
mathjax: true
layout: post
---

![game](https://github.com/HongchaoHu/HongchaoHu.github.io/blob/master/assets/gaming.jpg?raw=true)
Video Game Programming


# **First-Person Shooter Game Development**

In the realm of game development, creating a first-person shooter (FPS) game that stands out requires a blend of solid mechanics, impressive visuals, and intelligent game interactions. My journey of being a long-term gamer and the experience in doing such a game led me to combine traditional game development techniques with modern neural networks to enhance the player experience. 

## 1. **Conceptualization & Design**
The foundation of any FPS game lies in its core mechanics. I delved deep into the intricacies of C and C++ to design and implement fluid game mechanics. From the player's movement to the enemy AI, every aspect needs to be meticulously crafted to ensure smooth gameplay. <br>
<br>
I decided to take the early "DOOM" series as inspiration and reference to create a basic yet classic FPS gameplay. Drawing heavily from 'DOOM's pixelated yet gruesomely detailed style, we aimed to recapture that same heart-pounding tension and rapid, unyielding combat. While my core concept revolved around gun-shotting action, I also embedded cryptic lore scattered throughout the levels, offering a nod to the subtle, underplayed narratives of early FPS games.

Key Features:

* Dynamic Enemy AI: Enemies that adapt to the player's actions, making each encounter unique.
* Physics Engine: Realistic object interactions, enermy and character movements.
* Weapon Mechanics: A diverse arsenal with unique attributes and effects.

## 2. **Development Environment Setup**
I kicked off with `CMake` for cross-platform build automation, ensuring consistent builds across various platforms. Next, using VS Code equipped with C/C++ extensions offered a nimble yet powerful coding experience. The integrated debugger was invaluable for on-the-fly error checking and resolution. I leaned on GLFW for windowing and input, giving the game a responsive feel. The inclusion of `GLAD`, a loader for OpenGL, facilitated efficient rendering, letting me harness the power of the GPU for smooth graphics. Every component was meticulously chosen, each serving its unique purpose, harmonizing to create an environment where both code and creativity thrived.

## 3. Engine & Mechanics Development
In the early stages, I focused on emulating the game's "DOOM" like vintage mechanics. A fluid player control system was paramount, enabling seamless navigation through the game's map. By harnessing GLFW's input management capabilities, I ensured real-time responsiveness. This foundational layer accommodated more intricate features like weapon handling, environmental interactions, and basic enemy behaviors. Credit to [jdh](https://github.com/jdah) and [DOOM source code](https://github.com/id-Software/DOOM).

```C
#define MAP_SIZE 8
static u8 MAPDATA[MAP_SIZE * MAP_SIZE] = {
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 0, 0, 0, 3, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 2, 0, 4, 4, 0, 1,
    1, 0, 0, 0, 4, 0, 0, 1,
    1, 0, 3, 0, 0, 0, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
};
```

Building upon the basic engine, I added advanced mechanics like enemy AI pathfinding and a rudimentary physics system for enhanced realism.

```C
// Basic player movement mechanics
float playerSpeed = 2.5f;
if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
    playerPos += playerSpeed * playerFront;
if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
    playerPos -= playerSpeed * playerFront;
if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
    playerPos -= glm::normalize(glm::cross(playerFront, playerUp)) * playerSpeed;
if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
    playerPos += glm::normalize(glm::cross(playerFront, playerUp)) * playerSpeed;

// Simple enemy AI pathfinding towards the player
glm::vec3 enemyDirection = glm::normalize(playerPos - enemyPos);
enemyPos += enemySpeed * enemyDirection;
```

Here, a straightforward enemy AI attempts to follow the player by calculating the direction vector pointing towards the player and moving in that direction. While basic, this serves as the bedrock for more advanced AI behaviors.

## 4. Visual Effects & Rendering
Visuals are the soul of any game. Using OpenGL, I endeavored to craft a reminiscent of the pixelated ambiance of early 'DOOM' titles but with a modern twist. Although it looks very simple and ugly in today's video game graphic standard, it is decent considering I did not use any vertices, triangles, or light trace, just plain pixel rendering with the help of OpenGL.

```C
// Vertex and fragment shader source code
const char* vertexShaderSource = "..."; // vertex shader code
const char* fragmentShaderSource = "..."; // fragment shader code

// Compile vertex shader
GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
glCompileShader(vertexShader);

// Compile fragment shader
GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
glCompileShader(fragmentShader);

// Link shaders to a shader program
GLuint shaderProgram = glCreateProgram();
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragmentShader);
glLinkProgram(shaderProgram);
glUseProgram(shaderProgram);
```

## 5. Neural Networks for Predictive Player-Enemy Interactions
Harnessing the power of Neural Networks (NNs) can drastically improve player-enemy interactions in game development. By analyzing a player's past movements, decisions, and strategies, NNs can predict forthcoming actions with a significant degree of accuracy. This foresight enables the game engine to pre-render enemy responses, leading to highly responsive and real-time interactions. Such proactive rendering ensures that enemies react in a seemingly intuitive manner, almost as if they're "reading" the player's mind. This not only makes gameplay more challenging and engaging but also reduces lag and computational overhead by preempting and preparing for likely scenarios. The result is a game that feels alive, reactive, and immersive, offering players an unprecedented level of challenge and realism. <br>

![gameNNs](https://github.com/HongchaoHu/HongchaoHu.github.io/blob/master/assets/gameNNs.jpg?raw=true)

In our first-person shooter game, which draws inspiration from classics like DOOM, understanding player intent is crucial. In such games, players often follow patterns â€” they might prefer sneaking to direct confrontation, or they may have a favored weapon or strategy for specific enemy types. <br>
<br>
Utilizing Neural Networks (NNs), we can capture these patterns. For instance, let's say our game records player actions across multiple sessions. From this, the NN learns that a player frequently uses a sniper rifle from a distance before entering a new area. The next time this pattern starts, the NN predicts the probable sniper shot. Consequently, the game pre-renders a counter-move: perhaps an enemy ducking or using a shield, or even deploying a decoy. <br>

<br>

Please feel free to [contact me](mailto:hohu@ucsd.edu) if you would like to learn more about this exciting project or if you have any inquiries related to my skills and experience.
